<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
         <!--本网页主要是实现液压支架运动-->
        <script src="../three.js"></script>
        <script src="../OrbitControls.js"></script>
        <script src="../../examples/js/libs/dat.gui.min.js"></script>
		<script>
            //"https://cdn.bootcss.com/three.js/r83/three.min.js"

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            var camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 500 );
            camera.position.set( 100,100,100 );//从哪个角度上看 ，当从其他轴看时，坐标发生转动，只转一次。
            camera.lookAt( 0, 0, 0 );

            var scene = new THREE.Scene();
            
            //环境光    环境光颜色与网格模型的颜色进行RGB进行乘法运算
			var ambient = new THREE.AmbientLight(0xffffff);
            scene.add(ambient);

            //世界坐标系  
			var axesHelper = new THREE.AxesHelper(250);  
			scene.add(axesHelper);

            var allGroup = new THREE.Group();
            // 底座网格模型  x y z 长 高 宽
            var bottom1Mesh = boxMesh(80, 8, 30, 0, 4, 0);
            bottom1Mesh.name = "底座矩形1";
            var bottom2Mesh = boxMesh(5, 10, 30, -25,12,0);
            bottom2Mesh.name = "底座矩形2";
            var bottomGroup = new THREE.Group();
            bottomGroup.add(bottom1Mesh, bottom2Mesh);
            bottomGroup.name = "底座" ;

            // 液压圆柱模型
            var cylinder11Mesh = cylinderMesh(6, 20, -10, 18, 0);
            cylinder11Mesh.name = "液压圆柱1_1";
            var cylinder12Mesh = cylinderMesh(4, 25, -10 ,30, 0);
            cylinder12Mesh.name = "液压圆柱1_2";
            var cylinder21Mesh = cylinderMesh(6, 20, 15, 18, 0);
            cylinder21Mesh.name = "液压圆柱2_1";
            var cylinder22Mesh = cylinderMesh(4, 25, 15 ,30, 0);
            cylinder22Mesh.name = "液压圆柱2_2";
            var cylinderGroup = new THREE.Group();
            cylinderGroup.add(cylinder11Mesh, cylinder12Mesh,cylinder21Mesh,cylinder22Mesh);
            cylinderGroup.name = "液压支架" ;

            //顶梁
            var topBox = new THREE.Object3D();
			topBox.position.x = 0;
            topBox.position.y = 0;
            topBox.position.Z = 0;
			topBox.add(new THREE.AxesHelper(50));

            var topMesh = boxMesh(80, 8, 30, 15, 44, 0);
            topMesh.name = "顶梁";
            topBox.add(topMesh);

             //护帮
            var guardBoardBox = new THREE.Object3D();
			guardBoardBox.position.x = 55;
            guardBoardBox.position.y = 44;
            guardBoardBox.position.Z = 0;
            guardBoardBox.rotateZ(-Math.PI/4);//绕x轴旋转π/4Z
            guardBoardBox.add(new THREE.AxesHelper(150));

            var guardBoardMesh = boxMesh(20, 4, 25, 10,0,0);
            guardBoardBox.name = "护帮";
            guardBoardBox.add(guardBoardMesh);
            topBox.add(guardBoardBox);
            

            //侧护
            var sideGuarBox = new THREE.Object3D();
			sideGuarBox.position.x = -25;
            sideGuarBox.position.y = 44;
            sideGuarBox.position.Z = 0;
            sideGuarBox.rotateZ(Math.PI/4);//绕x轴旋转π/4Z
			sideGuarBox.add(new THREE.AxesHelper(150));

            var sideGuardMesh = boxMesh(36.2, 8, 30, -18.1,0,0);
            sideGuarBox.name = "侧护";
            sideGuarBox.add(sideGuardMesh)
            topBox.add(sideGuarBox)
            topBox.name="上顶";
            
            //连杆
            var rodCylinderBox = new THREE.Object3D();
			rodCylinderBox.position.x = -40;
            rodCylinderBox.position.y = 8;
            rodCylinderBox.position.Z = 0;
            rodCylinderBox.rotateZ(Math.PI/4);//绕x轴旋转π/4Z
			rodCylinderBox.add(new THREE.AxesHelper(150));

            var rodCylinderMesh = cylinderMesh(3, 15, 0, 7.5, 0);
            rodCylinderBox.name = "连杆";
            //rodCylinderMesh.rotateZ(Math.PI/4);//绕x轴旋转π/4Z
            rodCylinderBox.add(rodCylinderMesh);
            //scene.add(rodCylinderBox);
            
            //主体 
            var bodyBox = new THREE.Object3D();
			bodyBox.position.x = 0;
            bodyBox.position.y = 0;
            bodyBox.position.Z = 0;

            bodyBox.add(topBox);
            bodyBox.add(cylinderGroup);
            bodyBox.add(bottomGroup);
            bodyBox.add(rodCylinderBox)
            bodyBox.name = "主体";

            //推移

            var moveBox = new THREE.Object3D();
			moveBox.position.x = 0;
            moveBox.position.y = 0;
            moveBox.position.Z = 0;

            var moveBoxMesh = boxMesh(40, 8, 8, 20,4,0);
            var moveSphereMesh = sphereMesh(6, 46,4,0);
            moveBox.add(moveBoxMesh);
            moveBox.add(moveSphereMesh);
            moveBox.name ="推杆";

            //支架成组
            var zhijiaGroup = new THREE.Group();
            zhijiaGroup.add(moveBox,bodyBox)

            
            var zhijiaGroup1 = zhijiaGroup.clone();//克隆网格模型
            zhijiaGroup1.translateZ(50);//网格模型mesh平移

            // moveBox.scale.set(1.5,1.5,1.5);//几何体缩放
            scene.add(zhijiaGroup,zhijiaGroup1);
            // moveBox.translateY(0)



            // var box=new THREE.BoxGeometry(40,40,40);//创建一个立方体几何对象
            // var material=new THREE.MeshLambertMaterial({color:0x44BBff});//材质对象

            
            // var mesh1=new THREE.Mesh(box,material);//网格模型对象
            // mesh1.scale.set(0.5,0.5,0.5);
            // var mesh2 = mesh1.clone();//克隆网格模型
            // // mesh2.translate.x = 30;//网格模型mesh平移
            // // mesh1.translate.x = 100;//网格模型mesh平移
            
            // scene.add(mesh1);//网格模型添加到场景中
            // scene.add(mesh2);//网格模型添加到场景中
            // mesh2.translateX(100);//网格模型mesh平移

            //绕向量旋转和平移
            // var axis = new THREE.Vector3(1, 0, 1);
            // axis.normalize(); //向量归一化
            // //沿着axis轴表示方向平移100
            // zhijiaGroup.translateOnAxis(axis, 50);
            // zhijiaGroup.rotateOnAxis(axis,1.57)

            


            //面板控制
            control = new function () {
                this.护帮操作 = 0;
                this.立柱操作 = 0;
                this.推溜操作 = 0;
                this.拉架操作 = 0;
                this.操作架号 = 0;
                this.camera_rotation = '[0, 1, 0]';
            };
            //使用.listen() 可以从外部改变control的值
            function addController(){
            var gui = new dat.GUI();//需要修改
            gui.add(control, '护帮操作', -3.14, 0.5).step(0.1);
            gui.add(control, '立柱操作', -5, 10).min(-5).max(10).step(1);
            gui.add(control, '推溜操作', 0, 30).step(1).listen();
            gui.add(control, '拉架操作', 0, 30).step(1).listen();
            gui.add(control, '操作架号', 0, 1).step(1).listen();
            gui.add(control,'camera_rotation', {'不旋转': '[0, 1, 0]', '45度': '[1, 1, 0]', '90度': '[1, 0, 0]'}).onChange(val => {
                var parse = JSON.parse(val);
                camera.up.x=parse[0];
                camera.up.y=parse[1];
                camera.up.z=parse[2];
                renderer.render( scene, camera );
            });
            }
            
           

            // 球体网格模型创建函数
            function sphereMesh(R, x, y, z) {
            var geometry = new THREE.SphereGeometry(R, 25, 25); //球体几何体
            var material = new THREE.MeshPhongMaterial({
                color: 0x00ffff
            }); //材质对象Material
            var mesh = new THREE.Mesh(geometry, material); // 创建网格模型对象
            mesh.position.set(x, y, z);
            return mesh;
            }

            // 圆柱体网格模型创建函数
            function cylinderMesh(R, h, x, y, z) {
            var geometry = new THREE.CylinderGeometry(R, R, h, 50, 50); //球体几何体
            var material = new THREE.MeshPhongMaterial({
                color: 0xff00ff
            }); //材质对象Material
            var mesh = new THREE.Mesh(geometry, material); // 创建网格模型对象
            mesh.position.set(x, y, z);
            return mesh;
            }

            // 立方体网格模型创建函数
            function boxMesh(l, w, h, x,y, z) {
            var geometry = new THREE.BoxGeometry(l, w, h); //立方体几何体
            var material = new THREE.MeshPhongMaterial({
                color: 0x0000ff
            }); //材质对象Material
            var mesh = new THREE.Mesh(geometry, material); // 创建网格模型对象
            mesh.position.set(x, y, z);
            return mesh;
            }
            //余弦定理
            function cosFunc(a,b,c)
            {
                cosA = (b**2+c**2-a**2)/(2*b*c)
                return cosA;
            }







            var geometry = new THREE.BoxGeometry(20, 20, 20); //创建一个立方体几何对象Geometry
            var material = new THREE.MeshPhongMaterial({
            color: 0x0000ff,
            side: THREE.DoubleSide, //两面可见
            }); //材质对象Material

            var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh
            //scene.add(mesh);
            var tempY=0;//立柱操作
            var tempX=0;//推溜操作
            var moveTempX = 0; //移架操作
            //最大极限为53

            var animate = function () { //window的api
                requestAnimationFrame( animate ); //设置60fps，不使用setInterval的原因是可以在求其他请求时不加载
                //护帮操作
                var NUM = control.操作架号+2;
                angle1 = control.护帮操作;
                scene.children[NUM].getObjectByName("护帮").rotation.z = angle1;
                //调试时注意rotation.x=N,表示在最初的本地坐标旋转了N度，rotationX(N)表示在现在基础上又旋转了好多度。
                // oldRotateTop = Math.PI/4;
                // oldRotateRod = Math.PI/4;
                oldRotateTop = 0;
                oldRotateRod = 0;
                
                //立柱操作
                if (control.立柱操作 != tempY)
                {
                    scene.children[NUM].getObjectByName("上顶").translateY(control.立柱操作-tempY);
                    scene.children[NUM].getObjectByName("液压圆柱1_2").translateY(control.立柱操作-tempY);
                    scene.children[NUM].getObjectByName("液压圆柱2_2").translateY(control.立柱操作-tempY);

                    let a = 36.2 , b = 15 , c = Math.pow(((control.立柱操作 + 36.2)**2 +15**2),1/2);
                    x1 = Math.acos(cosFunc(a,b,c));
                    x2 = Math.abs(Math.atan((36.2 +control.立柱操作)/15));
                    console.log(x1+x2);
                    var temp1 = x1+x2 - Math.PI/2 ;
                    scene.children[NUM].getObjectByName("连杆").rotation.z = (temp1 - oldRotateRod);
                    console.log(temp1 - oldRotateRod);
                    oldRotateRod = temp1;

                    y1 = Math.acos(cosFunc(b,a,c));
                    y2 = Math.abs(Math.atan(15/(36.2 +control.立柱操作)));
                    console.log(y1+y2);
                    var temp2 =  Math.PI/2 - y1 - y2;
                    scene.children[NUM].getObjectByName("侧护").rotation.z = (temp2- oldRotateTop);
                    console.log(temp2 - oldRotateTop);
                    oldRotateTop = temp2;
                    tempY =control.立柱操作;
                }
                if(control.推溜操作 != tempX)
                {
                    scene.children[NUM].getObjectByName("推杆").translateX(control.推溜操作-tempX);
                    if(moveTempX>0)
                    {
                        control.拉架操作 = control.拉架操作-(control.推溜操作- tempX);
                        moveTempX =control.拉架操作;
                    }
                    tempX =control.推溜操作;
                }
                if(tempX>0 && control.拉架操作!=moveTempX )
                {
                    scene.children[NUM].getObjectByName("主体").translateX(control.拉架操作 - moveTempX);
                    control.推溜操作 = control.推溜操作-(control.拉架操作- moveTempX);
                    tempX =control.推溜操作;
                    moveTempX =control.拉架操作;
                    console.log("正常进入函数！");
                }

				renderer.render( scene, camera );
			};
            animate();
            addController();
            function render() {
            renderer.render(scene,camera);//执行渲染操作
            
			}
			render();
			var controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
            controls.addEventListener('change', render);//监听鼠标、键盘事件
            var angle1 = 0; 
            var angle2 = 0;
            function guardBoardRotateDown()
            {
                if(angle1-0.1 > 0.8 || angle1-0.1 <= -0.8) {
					angle1 = angle1;
                }else
                {
                    //angle1 = angle1-0.1
                }
                guardBoardBox.rotation.z = angle1;
                render();
            }
            function guardBoardRotateUp()
            {
                if(angle1 +0.1 >0.8 || angle1 +0.1 <= -0.8) {
					angle1 = angle1;
                }else
                {
                  
                    //angle1 = angle1+0.1
                }
                guardBoardBox.rotation.z = angle1;
                render();
            }

        </script>
        <button type = "button" onclick="guardBoardRotateDown()">护帮向下</button>
        <button type = "button" onclick="guardBoardRotateUp()">护帮向上</button>
	</body>
</html>